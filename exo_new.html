
<!-- OrbitControls example code used from https://threejs.org/examples/misc_controls_orbit.html -->
<!-- Base tooltip and point drawing code based on https://beta.observablehq.com/@grantcuster/using-three-js-for-2d-data-visualization -->

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Exoplanet Visualization</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: black;
				font-family:Arial, Helvetica, sans-serif;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				

				background-color: rgb(8, 0, 16);
				margin: 0px;
				overflow: hidden;
			}
			
			.dg .c input[type="text"] {
				visibility: hidden;
				width: 0px;
			}
			

			#info {
				color:white;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				box-sizing: border-box;
			}

			#legend-text {
				color: white;
			}

			#legend {
				display: none;
			}
			#pubdate {
				transition: opacity 2s; /* 设置过渡效果 */
			}
			.container {
				width: 800px;
				margin: auto;
				position: fixed;
				bottom: 0;
				left: 0;
			}

			#col1 {
				width: 40%;
				float: left;
				color: white;
			}

			#col2 {
				
				width: 30%;
				float: left;
				color: white;
			}

			#col2-content {
				top: 120px;
			}

			h3{
				text-align: left;
			}
		</style>
	</head>

	<!-- html for the legend -->
	<body>
		<div id="pubdate" style="position: absolute; bottom: 10px; left: 10px; opacity: 0"></div>
		<div id="legend" class='container'>
			<div id="col1">
					<h1 id="legend-title" style="color: white; text-decoration: underline; text-align: right">Loading...</h1>
					<div id="legend-text" style="text-align: left">
						<h3><u>Exoplanet Color/Temperature</u></h3>
						<img src="images/Heatmap_gradient.png">
						<br>
						<div id="cold" style="float:left">Cold</div><div id="hot" style="float: left; padding-left: 210px;">Hot</div>
						<br>
						<h3><u>Planet Size (Based On Initial View)</u></h3>
						<img style="padding-left: 20px;" width="3" height="5" src="images/white_small.png"> <div id="null" style="float:right; padding-right: 40%">Null Size Val</div>
						<br>
						<br>
						<img style="padding-left: 14px;" width="15" height="15" src="images/white.png"> <div id="small" style="float: right; padding-right: 50%">Small</div>
						<br>
						<br>
						<img width="40" height="40" src="images/white_big.png"> <div id="big" style="float:right; padding-right: 50%">Big</div>
						<br>
						
					</div>
			</div>
			<div id="col2">
				<div id="col2-content">
					<br>
					<br>
					<br>
						<h3><u>Other</u></h3>
						<img style="padding-left: 14px;" width="15" height="15" src="images/yellow.png"> <div id="yellow" style="float:right; padding-right: 30%">Null Temp Value</div>
						<br>
						<br>
						<img style="padding-left: 14px;" width="15" height="15" src="images/green.png"> <div id="green" style="float:right; padding-right: 20%">Temp Outlier Values</div>
						<br>
						<h3><u>In Selection Mode</u></h3>
						<img style="padding-left: 14px;" width="15" height="15" src="images/white.png"> <div id="white" style="float:right; padding-right: 30%">Selected Exoplanet</div>
						<br>
						<h3 style="color: white"><u><a href="index.html">Link to Exo Documentation</a></u></h3>
				</div>
			</div>
			
		</div>

		<script src="js/three.js"></script>
		<script src="js/d3.js"></script>
		<script src="js/underscore.js"></script>
        <script src="js/OrbitControls.js"></script>
		<script src="js/jquery-3.3.1.js"></script>
		<script src="js/dat.gui.min.js"></script>
		<script src="render.js"></script>
		<script src="points_new.js"></script>
		<!-- <script src="js/WebGL.js"></script> -->

		<!--Custom GLSL shaders for three.js. Based on code from https://waldemarlehner.github.io/three.js-fiddles/varyingSizePoints/ -->
		<script type ="x-shader/x-vertex" id="vertexshader">
			uniform float amplitude;
			attribute float size;
			attribute vec3 inputColor;
			varying vec3 vColor;
			attribute float alpha;
			varying float vAlpha;
			void main(){
				vAlpha = alpha;
				vColor = inputColor;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = size * ( 300.0 / -mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>
		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			varying float vAlpha;
			void main(){
				gl_FragColor = vec4(color * vColor, vAlpha*0.8);
				gl_FragColor = gl_FragColor * texture2D(texture, gl_PointCoord);
				//console.log(gl_FragColor.a)
				if ( gl_FragColor.a < 0.5 ) discard;
			}
		</script>

		<script>
			// render setting
			var showOnlyEarthLikePlanets = false;
			var renderMaxTemperature = 60000;
			var renderMinTemperature = 0;
			var RenderMaxStarRadius = 200;
			var RenderMinStarRadius = 0;
			var pl_tempQs;
			var pl_radQs;
			var renderMode = 0;//0 = render star info, 1 = render planet info
			var pl_maxTemp;
			var pl_minTemp;
			var pl_maxR;
			const mass_Earth = 5.972e24;//kg
			const radius_Earth = 6371000;//m
			var pl_minR;
			var topDiscmethodKeys ;
			var topDisclocaleKeys ;
			var topDisctelescopeKeys ;
			var topDiscfacilityKeys ;
			var RenderSiblings = [];
			var RenderHabitable = false;
			var sizescale = 1;
			var customShaderMaterial = null; // check whether to use custom shader material
			var UseRandomColor = true; //if not, color by temperature
			var SizeFactor = 1; // 1 = random size， 2 = stellar radius， 3 = siblings count
			var customSizeMin = 10;
			var customSizeMax = 50;
			var TempQs;
			var RadQs;
			var RawplanetData = null; //保存原始数据
			var filtered_RawplanetData = null; //经过filter筛选的原始数据
			var filtered_StarData = null;//筛选后的恒星数据，读取其planets属性可以知道其行星数据
			var pl_radQs;
			var pl_massQs;
			var DensityQs;
			var cartesianCoords = []; // 点坐标
			var cartesianDist = []; // 距离
			var pointSizes = []; // 点大小
			var pointColors = [];// 点颜色
			var TemperatureoutlierNames = []; // 筛选温度异常值
			var RadiusoutlierNames = [];// 筛选半径异常值
			var percents = []; // (for debuggin) stores data percents calculated using min/max temp
			var habitablePlanets = 'Display all exoplanets';
			var conservativelyHabitable = ['Proxima Cen b', 'Kepler-442 b', 'Kepler-452 b', 'Wolf 1061 c', 'Kepler-1229 b', 'Kepler-62 f', 
				'Kepler-186 f', 'TRAPPIST-1 d', 'TRAPPIST-1 e', 'TRAPPIST-1 f', 'TRAPPIST-1 g', 'LHS 1140 b', 'Kepler-1638 b', 'Teegarden\'s Star b']
			let all_discmethod = [];
			var all_disclocale = [];
			var all_disctelescope = [];
			var all_discfacility = [];
			var PlanetofInterest = null;
			let mappable = 0; // counts the mappable exoplanets
			
			Array.prototype.diff = function(a) {
				return this.filter(function(i) {return a.indexOf(i) < 0;});
			}

			// given an array, filters out the outlier values from the array
			// needed to filter out outlier values for temperature values so that color scale is accurate
			function interquartileFiltering(values){
				if(values.length < 4) return values;

				let nums, q1, q3, iqr, maxValue, minValue;

				nums = values.slice().sort((a, b) => a - b);

				if((nums.length / 4) % 1 === 0){
					q1 = 1/2 * (nums[(nums.length / 4)] + nums[(nums.length / 4) + 1]);
					q3 - 1/2 * (nums[(nums.length * (3 / 4))] + nums[(nums.length * (3 / 4)) + 1]);
				}
				else{
					q1 = nums[Math.floor(nums.length / 4 + 1)];
					q3 = nums[Math.ceil(nums.length * (3 / 4) + 1)];
				}

				iqr = q3 - q1;

				maxValue = q3 + iqr * 1.5;
				minValue = q1 + iqr * 1.5;
				maxValue = Math.max(...nums);
				minValue = Math.min(...nums);
				return nums.filter((x) => (x >= minValue) && (x <= maxValue));
			}
			function calculateESI(relativeMass, relativeRadius, surfaceTemperature, density) {
				// 地球的参数
				const earthDensity = 1.0; // 地球密度（单位：地球密度）
				const earthSurfaceTemperature = 288.0; // 地球表面温度（单位：开尔文）
			
				// 参数权重
				const weightRadius = 0.57;
				const weightDensity = 1.07;
				const weightEscapeVelocity = 0.7;
				const weightSurfaceTemperature = 5.58;
			
				// 计算相对逃逸速度
				const escapeVelocity = Math.sqrt(relativeMass / relativeRadius);
			
				// 计算相似度
				function similarityIndex(value, earthValue, weight) {
					return Math.pow(1 - Math.abs((value - earthValue) / (value + earthValue)), weight);
				}
			
				// 计算各参数的相似度指数
				const esiRadius = similarityIndex(relativeRadius, 1.0, weightRadius);
				const esiDensity = similarityIndex(density, earthDensity, weightDensity);
				const esiEscapeVelocity = similarityIndex(escapeVelocity, 1.0, weightEscapeVelocity);
				const esiSurfaceTemperature = similarityIndex(surfaceTemperature, earthSurfaceTemperature, weightSurfaceTemperature);
			
				// 计算最终的 ESI
				const esi = Math.pow(esiRadius * esiDensity * esiEscapeVelocity * esiSurfaceTemperature, 1 / 4);
			
				return esi;
			}
			
			function scalePlanetJRadius(radj, minScale, maxScale, minVal, maxVal){
				if(radj == null) return 2;

				let percent = (radj - minVal)/(maxVal - minVal);
				
				return minScale + (percent * (maxScale - minScale));
			}

			function twoColorHeatMap(val, minVal, maxVal, RGBa, RGBb){
				// if(val == null) return [255, 255, 0];

				let value = (val - minVal)/(maxVal - minVal);
				if (value > 1) value = 1;

				let aR = RGBa[0], aG = RGBa[1], aB = RGBa[2];
				let bR = RGBb[0], bG = RGBb[1], bB = RGBb[2];

				let finalRed = (bR - aR) * value + aR;
				let finalGreen = (bG - aG) * value + aG;
				let finalBlue = (bB - aB) * value + aB;

				return [finalRed, finalGreen, finalBlue];
			}
			//三分位数差值颜色
			function quartileColorMap(val, Qs, RGBa, RGBb){
				let minVal = Qs[0];
				let maxVal = Qs[1];
				let Q1 = Qs[2];
				let Q3 = Qs[3];
				r0 = RGBa[0], g0 = RGBa[1], b0 = RGBa[2];
				r3 = RGBb[0], g3 = RGBb[1], b3 = RGBb[2];
				r1 = (r0*3+r3)/4;
				r2 = (r0+r3*3)/4;
				g1 = (g0*3+g3)/4;
				g2 = (g0+g3*3)/4;
				b1 = (b0*3+b3)/4;
				b2 = (b0+b3*3)/4;

				let RGB1 = [r1, g1, b1];
				let RGB2 = [r2, g2, b2];

				let value;

				if (val <= Q1) {
					value = (val - minVal) / (Q1 - minVal);
					return interpolateColor(value, RGBa, RGB1);
				} else if (val <= Q3) {
					value = (val - Q1) / (Q3 - Q1);
					return interpolateColor(value, RGB1, RGB2);
				} else {
					value = (val - Q3) / (maxVal - Q3);
					return interpolateColor(value, RGB2, RGBb);
				}
			}
			function getQuartile(filteredData){

				//console.log("filteredData",filteredData);
				let sortedData = filteredData.sort((a, b) => a - b);
				let min = sortedData[0];
				let max = sortedData[sortedData.length - 1];
				let Q1 = sortedData[Math.floor(sortedData.length / 4)];
				let Q2 = sortedData[Math.floor(sortedData.length / 2)];
				let Q3 = sortedData[Math.floor(sortedData.length * 3 / 4)];
				return [min, max, Q1, Q2, Q3];
			}
			function interpolateColor(value, RGB1, RGB2) {
				let r1 = RGB1[0], g1 = RGB1[1], b1 = RGB1[2];
				let r2 = RGB2[0], g2 = RGB2[1], b2 = RGB2[2];
			
				let finalRed = (r2 - r1) * value + r1;
				let finalGreen = (g2 - g1) * value + g1;
				let finalBlue = (b2 - b1) * value + b1;
			
				return [finalRed, finalGreen, finalBlue];
			}
			//传入经过过滤的数据
			
			function renderScene(data, delay){
				UseRandomColor = sceneProperties.randomColor;
				SizeFactor = sceneProperties.SizeFactor;
				filtered_RawplanetData = data;
				let seen_hostname = new Set();
				//每个恒星只显示一个点
				filtered_StarData = data.filter(d => {
					if (seen_hostname.has(d.hostname)) {
						return false;
					} else {
						seen_hostname.add(d.hostname);
						return true;
					}
				});
				let hostnameToIndex = new Map();
				filtered_StarData.forEach((d, i) => {
					if (hostnameToIndex[d.hostname] === undefined) {
						hostnameToIndex.set(d.hostname, i);
					}
				});

				filtered_StarData.forEach(d => delete d.planets);
				console.log(hostnameToIndex);
				filtered_RawplanetData.forEach((exoplanet, i) => {
					let firstsibleidx = hostnameToIndex.get(exoplanet.hostname);
					//在行星数组中标出其所处恒星的索引
					filtered_RawplanetData[i].firstsible = firstsibleidx ? firstsibleidx : null;
					//在恒星数组中标出其所包含的行星的索引
					if (filtered_StarData[firstsibleidx].planets == null){
						filtered_StarData[firstsibleidx].planets = [];
					}
					filtered_StarData[firstsibleidx].planets.push(i);
				});
				exoplanetData = filtered_StarData;
				filtered_StarData = filtered_StarData.filter(d => d.sy_dist != null && d.sy_dist != 0);
				exoplanetData = filtered_StarData;
				for(var i = 0; i < filtered_StarData.length; i++){
					let cartesianCoord = raDecToXYZ(filtered_StarData[i].ra, filtered_StarData[i].dec, filtered_StarData[i].sy_dist*1.5+1);
					cartesianCoords.push(cartesianCoord);
				}

				let countNonMapped = 0; //counts the nonmappable exoplanets

				
				for(var i = 0; i < filtered_StarData.length; i++){
					cartesianDist.push(Math.sqrt((cartesianCoords[i][0] * cartesianCoords[i][0]) + (cartesianCoords[i][1] * cartesianCoords[i][1]) + (cartesianCoords[i][2] * cartesianCoords[i][2])));
					// get exoplanet x, y, z coordinates and exoplanet name, stored in js object
					generated_points.push({name: filtered_StarData[i].hostname, coords: raDecToXYZ(filtered_StarData[i].ra, filtered_StarData[i].dec, filtered_StarData[i].sy_dist*1.5+1)});
				}

				maxRadJ = RadQs[1];
				minRadJ = RadQs[0];
				maxTemp = TempQs[1];
				minTemp = TempQs[0];
				console.log(maxTemp, minTemp, maxRadJ, minRadJ);
				// store all colors, sizes, and vertices of the planets
				let colors = [];
				let sizes = [];
				let verts = [];

				let count = 0;
				
				// get size and color values for each planet
				for(var i = 0; i < filtered_StarData.length; i++){	
					if (renderMode == 1){
						let newColor = twoColorHeatMap(filtered_StarData[i].planets.length, 1, 7, [128, 0, 128], [173, 216, 230]);
						
						let finalColor = new THREE.Color(convertRGBToScaleOne(newColor[0]), convertRGBToScaleOne(newColor[1]), convertRGBToScaleOne(newColor[2]));
						colors.push(finalColor.r, finalColor.g, finalColor.b);
						pointColors.push(finalColor);
						let size = scalePlanetJRadius(filtered_StarData[i].planets.length, 10, 80, 1, 7)*sizescale;
							sizes.push(size);
					
					}
					else{
						if(SizeFactor ==  1){
							// size在5=80之间随机
							let size = (Math.random() * (30 - 10) + 10)*sizescale;
							sizes.push(size);
							//pointSizes.push(size);
						}
						if(SizeFactor == 2){
							size = scalePlanetJRadius(filtered_StarData[i].st_rad, 10, 80, minRadJ, maxRadJ)*sizescale;
							sizes.push(size);
							//pointSizes.push(size);
						}
						if(SizeFactor == 3){
							size = scalePlanetJRadius(filtered_StarData[i].sy_pnum, 10, 80, 1, 7)*sizescale;
							sizes.push(size);
							//pointSizes.push(size);
						}
						
						
							if (UseRandomColor == true){
								
								let newColor = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
								
								let finalColor = new THREE.Color(convertRGBToScaleOne(newColor[0]), convertRGBToScaleOne(newColor[1]), convertRGBToScaleOne(newColor[2]));
								colors.push(finalColor.r, finalColor.g, finalColor.b);
								pointColors.push(finalColor);
							}
							else{	
								if(filtered_StarData[i].st_teff != null) {
									let newColor = astroColorScale(filtered_StarData[i].st_teff);
									let finalColor = new THREE.Color(convertRGBToScaleOne(newColor[0]), convertRGBToScaleOne(newColor[1]), convertRGBToScaleOne(newColor[2]));
									colors.push(finalColor.r, finalColor.g, finalColor.b);
									pointColors.push(finalColor);
								}
								else 
								{
				
									//console.log("finalColor",finalColor);
									let finalColor = new THREE.Color(convertRGBToScaleOne(newColor[0]), convertRGBToScaleOne(newColor[1]), convertRGBToScaleOne(newColor[2]));
									colors.push(finalColor.r, finalColor.g, finalColor.b);
									pointColors.push(finalColor);
								}
							}
					}
				}
				pointSizes = sizes;
				//pointColors = colors;
				
				// 坐标
				for (let datum of generated_points) {
					verts.push(datum.coords[0], datum.coords[1], datum.coords[2]);
					
				}
				// 根据以上数据渲染点
				let pointsGeometry = new THREE.BufferGeometry();
				pointsGeometry.addAttribute("position",new THREE.BufferAttribute(new Float32Array(verts),3));
				pointsGeometry.addAttribute("inputColor",new THREE.BufferAttribute(new Float32Array(colors),3));
				//pointsGeometry.addAttribute("size",new THREE.BufferAttribute(new Float32Array(sizes),1));
				//sizes = new Float32Array(sizes.length).fill(5);
				if (delay > 0){
				alphas = new Float32Array(verts.length / 3).fill(0);
				}

				else{
					alphas = new Float32Array(verts.length / 3).fill(1);
				}

				pointsGeometry.addAttribute("size",new THREE.BufferAttribute(new Float32Array(sizes),1));
				pointsGeometry.addAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
				pointsGeometry.computeBoundingSphere();
				
				customShaderMaterial = new THREE.ShaderMaterial({
					uniforms: {
						amplitude: {value:1.0},
						color: {value: new THREE.Color(0xFFFFFF)},
						texture: {value: circle_sprite},
						alpha: {value: 0.0}
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					depthTest:true,
				});

				points = new THREE.Points(pointsGeometry, customShaderMaterial);
				var discmethod_dict = {};
				
				scene.add(points);
				
				// 每个点之间的延迟（毫秒）

				if (delay > 0){

					let filtered_RawplanetData_sortedByDate = filtered_RawplanetData.sort((a, b) => {
						let dateA = new Date(a.disc_pubdate);
						let dateB = new Date(b.disc_pubdate);
						return dateA - dateB;
					});
					var pubdate = document.getElementById('pubdate');
					pubdate.style.display = 'block';
					pubdate.style.fontFamily = 'Arial'; // 设置字体为 Arial
					pubdate.style.color = 'white'; 
					pubdate.style.fontSize = '40px'; // 设置字体大小
					// 设置颜色为白色
					console.log(pubdate);
					pubdate.style.opacity = '1';
					//在画布左下角显示filtered_RawplanetData_sortedByDate.disc_pubdate
					//console.log(filtered_RawplanetData_sortedByDate);
					for (let i = 0; i < filtered_RawplanetData_sortedByDate.length; i++) {
						setTimeout(() => {
								idx = filtered_RawplanetData_sortedByDate[i].firstsible;
								pointsGeometry.attributes.alpha.array[idx] = 1;
								pointsGeometry.attributes.size.array[idx] += 10;
								//console.log(star_cnt);
								pointsGeometry.attributes.alpha.needsUpdate = true;
								pointsGeometry.attributes.size.needsUpdate = true;
								
								pubdate.textContent = filtered_RawplanetData_sortedByDate[i].disc_pubdate;
								console.log(pubdate);
						}, i * delay);
					}
					//做一个动画使得pubdate逐渐消失
					setTimeout(() => {
						pubdate.style.opacity = '0';
					}, filtered_RawplanetData_sortedByDate.length * delay);
			}
				
				
		
			}
			function astroColorScale(temp){
				if (temp < 3500){
					return interpolateColor(temp/3500, [128, 0, 0], [255, 0, 0]);
				}
				else if (temp < 5000){
					// interpolate between red and orange
					return interpolateColor((temp-3500)/1500, [255, 0, 0], [255, 128, 0]);
				}
				else if (temp < 6500){
					// interpolate between orange and yellow
					return interpolateColor((temp-5000)/1500, [255, 128, 0], [255, 255, 0]);
					
				}
				else if (temp < 10000){
					// interpolate between yellow and white

					return interpolateColor((temp-6500)/3500, [255, 255, 0], [255, 255, 224]);
				}
				else if (temp < 20000){
					// interpolate between white and light blue

					return interpolateColor((temp-10000)/10000, [255, 255, 224], [255, 255, 255]);
				}
				else if (temp < 30000){
					// interpolate between white and light blue

					return interpolateColor((temp-20000)/10000, [255, 255, 255], [128, 128, 255]);
				}
				else{
					return [128, 128, 255];
				}


			}
			function convertRGBToScaleOne(RGB){
				return RGB/255;
			}

			// get the exoplanet data from csv
			
			d3.csv('./data2024.csv').then(data => {
				$('#legend-title').text(function() { return "Legend"});
				var discmethodCounts = {};
				var disclocaleCounts = {};
				var disctelescopeCounts = {};
				var discfacilityCounts = {};
				data.forEach(d => {
					// add all discmethod values to array
					//console.log(d);
					discmethodCounts[d.discoverymethod] = (discmethodCounts[d.discoverymethod] || 0) + 1;
					disclocaleCounts[d.disc_locale] = (disclocaleCounts[d.disc_locale] || 0) + 1;
					disctelescopeCounts[d.disc_telescope] = (disctelescopeCounts[d.disc_telescope] || 0) + 1;
					discfacilityCounts[d.disc_facility] = (discfacilityCounts[d.disc_facility] || 0) + 1;
					if(!all_discmethod.includes(d.discoverymethod)){
						//console.log(d.discoverymethod);
						all_discmethod.push(d.discoverymethod);
					}
					if(!all_disclocale.includes(d.disc_locale)){
						all_disclocale.push(d.disc_locale);
					}
					if(!all_disctelescope.includes(d.disc_telescope)){
						all_disctelescope.push(d.disc_telescope);
					}
					if(!all_discfacility.includes(d.disc_facility)){
						all_discfacility.push(d.disc_facility);
					}
					if (d.pl_dens > 11){
						d.pl_dens = 0;
					}
					for (let key in d) {
						
					  if (!isNaN(d[key])) {
						
						d[key] = +d[key];  // 将数值字符串转换为数值
					  }
					}
					//d.vesc = calculateEscapeVelocity(d.pl_bmasse, d.pl_rade);

					d.esi = calculateESI(d.pl_bmasse, d.pl_rade, d.pl_eqt, d.pl_dens);
				});
				

				//console.log("all_discmethod",all_discmethod);
				console.log("all_disclocale",all_disclocale);

				function getTopThreeKeysList(obj) {
					// 将对象转换为数组，数组的每个元素是一个包含键和值的数组
					var entries = Object.entries(obj);
				
					// 按值从大到小排序数组
					entries.sort((a, b) => b[1] - a[1]);
				
					// 创建一个新的数组，包含出现次数最高的3个键
					var topThreeKeys = [];
					for (var i = 0; i < 10 && i < entries.length; i++) {
						topThreeKeys.push(entries[i][0]);
					}
				
					return topThreeKeys;
				}
				function getTopThreeKeysList(obj) {
					// 将对象转换为数组，数组的每个元素是一个包含键和值的数组
					var entries = Object.entries(obj);
				
					// 按值从大到小排序数组
					entries.sort((a, b) => b[1] - a[1]);
				
					// 创建一个新的数组，包含出现次数最高的3个键
					var topThreeKeys = [];
					for (var i = 0; i < 3 && i < entries.length; i++) {
						topThreeKeys.push(entries[i][0]);
					}
				
					return topThreeKeys;
				}
				
				topDiscmethodKeys = getTopThreeKeysList(discmethodCounts);
				topDisclocaleKeys = getTopThreeKeysList(disclocaleCounts);
				topDisctelescopeKeys = getTopThreeKeysList(disctelescopeCounts);
				topDiscfacilityKeys = getTopThreeKeysList(discfacilityCounts);
				
				console.log(topDiscmethodKeys);
				console.log(topDisclocaleKeys);
				console.log(topDisctelescopeKeys);
				console.log(topDiscfacilityKeys);
				
				RawplanetData = data;
				//
				let filteredData = RawplanetData.map(d => d.st_teff);
				TempQs = getQuartile(filteredData);
			
				//console.log("tempMinMax",TempQs);
				filteredData = RawplanetData.filter(d => !RadiusoutlierNames.includes(d.pl_name)).map(d => d.st_rad);
				RadQs = getQuartile(filteredData);

				filteredData = RawplanetData.map(d => d.pl_rade);
				pl_radQs = getQuartile(filteredData);

				filteredData = RawplanetData.map(d => d.pl_bmasse);
				pl_massQs = getQuartile(filteredData);


				DensityQs = getQuartile(RawplanetData.map(d => d.pl_dens));
				console.log("DensityQs", DensityQs);
				console.log("pl_radQs", pl_radQs);
				console.log("pl_massQs", pl_massQs);

				
				renderScene(data, 0);
				// actually, data here is stellar data
			})
			.catch(error => console.error(error));
			// initialize and animate the scene
			init();
			animate();

			function reRenderScene(Delay){
				scene.remove(points);
				pubdate = document.getElementById('pubdate');
				pubdate.style.opacity = '0';
				discmethod = sceneProperties.discmethod;
				disclocale = sceneProperties.disclocale;
				disctelescope = sceneProperties.disctelescope;
				discfacility = sceneProperties.discfacility;
				if((discfacility) == "TESS"){
					discfacility = "Transiting Exoplanet Survey Satellite (TESS)";
				}
				if(disctelescope == "Kepler Telescope"){
					disctelescope = "0.95 m Kepler Telescope";
				}
				if(disctelescope == "TESS Telescope"){
					disctelescope = "0.1 m TESS Telescope";
				}
				console.log(discmethod, disclocale, disctelescope, discfacility);
				points = null;
				generated_points = [];
				colors = [];
				pointColors = [];
				pointSizes = [];
				maxT = sceneProperties.maxT;
				minT = sceneProperties.minT;
				maxR = sceneProperties.maxR;
				minR = sceneProperties.minR;
				pl_maxR = sceneProperties.pl_maxR;
				pl_minR = sceneProperties.pl_minR;
				pl_maxM = sceneProperties.pl_maxM;
				pl_minM = sceneProperties.pl_minM;
				pl_maxDens = sceneProperties.pl_maxDens;
				pl_minDens = sceneProperties.pl_minDens;
				//console.log(maxT, minT, maxR, minR);
				rerenderData = RawplanetData.filter(d=>d.st_teff >= minT && d.st_teff <= maxT && d.st_rad >= minR && d.st_rad <= maxR);
				rerenderData = rerenderData.filter(d=>d.pl_rade >= pl_minR && d.pl_rade <= pl_maxR && d.pl_bmasse >= pl_minM && d.pl_bmasse <= pl_maxM && d.pl_dens >= pl_minDens && d.pl_dens <= pl_maxDens);
				
				if (discmethod != "all" && discmethod != 'others'){
					rerenderData = rerenderData.filter(d=>d.discoverymethod == discmethod);
				}
				if (discmethod == 'others'){
					rerenderData = rerenderData.filter(d=>!topDiscmethodKeys.includes(d.discoverymethod));
				}
				if (disclocale != "all" && disclocale != 'others'){
					rerenderData = rerenderData.filter(d=>d.disc_locale == disclocale);
				}
				if (disclocale == 'others'){
					rerenderData = rerenderData.filter(d=>!topDisclocaleKeys.includes(d.disc_locale));
				}
				if (disctelescope != "all" && disctelescope != 'others'){
					rerenderData = rerenderData.filter(d=>d.disc_telescope == disctelescope);
				}
				if (disctelescope == 'others'){
					//console.log(d.disc_telescope);
					console.log(topDisctelescopeKeys);
					rerenderData = rerenderData.filter(d=>!topDisctelescopeKeys.includes(d.disc_telescope));
				}
				if (discfacility != "all" && discfacility != 'others'){
					rerenderData = rerenderData.filter(d=>d.disc_facility == discfacility);
				}
				if (discfacility == 'others'){
					rerenderData = rerenderData.filter(d=>!topDiscfacilityKeys.includes(d.disc_facility));
				}
				stars = sceneProperties.renderstarcount;
				siblings = sceneProperties.rendersiblingcount;
				if (stars != -1){
					rerenderData = rerenderData.filter(d=>d.sy_snum == stars);
				}
				if (siblings != -1){
					rerenderData = rerenderData.filter(d=>d.sy_pnum == siblings);
				}
				
				
				if (RenderHabitable){
					rerenderData = rerenderData.filter(d=>conservativelyHabitable.includes(d.pl_name));
				}
				//sizescale = Math.min(Math.sqrt(RawplanetData.length/rerenderData.length),5);
				sizescale = 1.5;
				console.log(rerenderData.length);
				renderScene(rerenderData, Delay);
			}

			// resets the camera to original position/orientation
			function resetCamera() {
				camera.position.set(400, 200, 0);
				controls.target = new THREE.Vector3(0,0,0);
			}

			var legendShown = true; // checks whether legend should be shown


			// hide and show the legend
			function hideLegend(){
				//update legend values
				$('#legend').css({"display": "none"});
			}

			function showLegend(){
				//update legend values
				$('#legend').css({"display": "block"});
			}
			
			// Hover and tooltip interaction
            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 10;

			// adds the container in which highlighted points are rendered
            hoverContainer = new THREE.Object3D()
			scene.add(hoverContainer);
			addEarth(scene);
			
			var sceneProperties = {
				autoRotate: true,
				// showOnlyEarthLikePlanets: false,
				randomColor: false,
				SizeFactor: 2,
				usestarcolor: function() {renderMode = 0;reRenderScene(0);},
				useplanetcolor: function() {renderMode = 1;reRenderScene(0);},
				habitable: 'Display all',
				reRender: function() {renderMode = 1;hideMainTooltip();removeHighlights();reRenderScene(2)},
				resetCamera: function() {resetCamera()},
				displayLegend: true,
				hideTooltips: function(){
					hideMainTooltip();
					hideTooltip2();
				},
				displayLegend: true,
				maxT: 40000,
				minT: 0,
				maxR: 100,
				minR: 0,
				pl_maxM: 89700,
				pl_minM: 0,
				pl_maxR:100,
				pl_minR:0,
				pl_maxDens:11,
				pl_minDens:0,
				maxTBar: 10000,
				minTBar: 0,
				maxRBar: 10000,
				minRBar: 0,
				pl_maxMBar: 10000,
				pl_minMBar: 0,
				pl_maxRBar: 10000,
				pl_minRBar: 0,
				pl_maxDensBar: 10000,
				pl_minDensBar: 0,
				randomColor: false,
				renderstarcount: -1,
				rendersiblingcount: -1,
				search: '',
				discmethod: 'all',
				disclocale: 'all',
				disctelescope: 'all',
				discfacility: 'all',
				
			}

			// add buttons/folders to dat.gui
			
			var gui = new dat.GUI({width: 400});
			//var discmethodOptions = {'Transit': 0', 'Radial Velocity': 1, 'Microlensing': 2, 'Imaging': 3, 'others': 1, 'all': -1};
			var autoRotateToggle = gui.add(sceneProperties, 'autoRotate').name('Auto Rotate').listen();
			autoRotateToggle.onChange(function(value){controls.autoRotate = value});
			var resetCameraButton = gui.add(sceneProperties, 'resetCamera').name('Reset Camera');
			var colorfolder = gui.addFolder('Color Options');
			var starcolorbutton = colorfolder.add(sceneProperties, 'usestarcolor').name('Stellar Temperature').listen();
			var planetcolorbutton = colorfolder.add(sceneProperties, 'useplanetcolor').name('Planets of Interest').listen();
			colorfolder.open();
			var reloadFolder = gui.addFolder('Discovery History Animation');
			// var tempOutliersToggle = reloadFolder.add(sceneProperties, 'renderWithTempOutliers').name('Render ETemp Outliers').listen();
			// tempOutliersToggle.onChange(function(value){renderWithTempOutliers = value});
			var colorOptions = { 'By Temperature': false}; 
			var SizeOptions = { 'By Stellar Radius': 2, 'By Sibling Count': 3}; 
			var starCountOptions = { 'all': -1, '1': 1, '2': 2, '3': 3, '4': 4}; 
			var siblingCountOptions = { 'all': -1, '1': 1, '2': 2, '3': 3, '4': 4,'5': 5, '6': 6,'7': 7, '8': 8}; 

			gui.add(sceneProperties, 'reRender').name("Play Animation");
			
			var filterFolder = gui.addFolder('Star Features');
			MaxTcontroller = filterFolder.add(sceneProperties, 'maxTBar', 0, 10000).name('Max Temperature:40000').onChange(()=>reRenderScene(0));
			MinTcontroller = filterFolder.add(sceneProperties, 'minTBar', 0, 10000).name('Min Temperature: 0').onChange(()=>reRenderScene(0));
			MaxRcontroller = filterFolder.add(sceneProperties, 'maxRBar', 0, 10000).name('Max Radius:109.49').onChange(()=>reRenderScene(0));
			MinRcontroller = filterFolder.add(sceneProperties, 'minRBar', 0, 10000).name('Min Radius:0').onChange(()=>reRenderScene(0));
			
			colorController = filterFolder.add(sceneProperties, 'randomColor', colorOptions).name('Color');
			colorController.onChange(function(value) {
				sceneProperties.randomColor = value;
				console.log("UseRandomColor",value,UseRandomColor,sceneProperties.randomColor);
				//console.log("UseRandomColor",value,UseRandomColor,sceneProperties.randomColor);
				reRenderScene(0);
			});

			SizeController = filterFolder.add(sceneProperties, 'SizeFactor', SizeOptions).name('Size');
			SizeController.onChange(function(value) {
				sceneProperties.SizeFactor = value;
				
				//console.log("SizeFactor",value,SizeFactor,sceneProperties.SizeFactor);
				reRenderScene(0);
			});
			
			
			starCountController = filterFolder.add(sceneProperties, 'renderstarcount', starCountOptions).name('Star(s) in System');
			starCountController.onChange(function(value) {
				sceneProperties.renderstarcount = value;
				reRenderScene(0);
			});

			siblingCountController = filterFolder.add(sceneProperties, 'rendersiblingcount', siblingCountOptions).name('Sibling(s) in System');
			siblingCountController.onChange(function(value) {
				sceneProperties.rendersiblingcount = value;
				reRenderScene(0);
			});
			MaxTcontroller.onChange(()=>{
				renderMode = 0;
				PlanetfilterFolder.close();
				min = TempQs[0];
				max = TempQs[1];
				Q1 = TempQs[2];
				Q2 = TempQs[3];
				Q3 = TempQs[4];
				if(sceneProperties.maxTBar < 2500){
					sceneProperties.maxT = sceneProperties.maxTBar / 2500 * Q1;
				}
				else if(sceneProperties.maxTBar < 5000){
					sceneProperties.maxT = Q1 + (sceneProperties.maxTBar - 2500) / 2500 * (Q2 - Q1);
				}
				else if(sceneProperties.maxTBar < 7500){
					sceneProperties.maxT = Q2 + (sceneProperties.maxTBar - 5000) / 2500 * (Q3 - Q2);
				}
				else if(sceneProperties.maxTBar < 9500){
					sceneProperties.maxT = Q3 + (sceneProperties.maxTBar - 7500) / 2000 * (20000 - Q3);
					
				}
				else{
					sceneProperties.maxT = 20000 + (sceneProperties.maxTBar - 9500) / 500 * (max - 20000);
				}
				//console.log("maxT",sceneProperties.maxT);
				MaxTcontroller.name('Max Temperature: '+sceneProperties.maxT.toFixed(0).toString());
			reRenderScene(0);
			}
			);
			MaxRcontroller.onChange(()=>{
				renderMode = 0;
				PlanetfilterFolder.close();
				min = RadQs[0];
				max = RadQs[1];
				Q1 = RadQs[2];
				Q2 = RadQs[3];
				Q3 = RadQs[4];
				if(sceneProperties.maxRBar < 2500){
					sceneProperties.maxR = sceneProperties.maxRBar / 2500 * Q1;
				}
				else if(sceneProperties.maxRBar < 5000){
					sceneProperties.maxR = Q1 + (sceneProperties.maxRBar - 2500) / 2500 * (Q2 - Q1);
				}
				else if(sceneProperties.maxRBar < 7500){
					sceneProperties.maxR = Q2 + (sceneProperties.maxRBar - 5000) / 2500 * (Q3 - Q2);
				}
				else if(sceneProperties.maxRBar < 9500){
					sceneProperties.maxR = Q3 + (sceneProperties.maxRBar - 7500) / 2000 * (50 - Q3);
					
				}
				else{
					sceneProperties.maxR = 50 + (sceneProperties.maxRBar - 9500) / 500 * (max - 50);
				}
				//console.log("maxR",sceneProperties.maxR);
				MaxRcontroller.name('Max Radius: '+sceneProperties.maxR.toFixed(3).toString());
			reRenderScene(0);
			}
			);
			MinTcontroller.onChange(()=>{
				renderMode = 0;
				PlanetfilterFolder.close();
				min = TempQs[0];
				max = TempQs[1];
				Q1 = TempQs[2];
				Q2 = TempQs[3];
				Q3 = TempQs[4];
				if(sceneProperties.minTBar < 2500){
					sceneProperties.minT = sceneProperties.minTBar / 2500 * Q1;
				}
				else if(sceneProperties.minTBar < 5000){
					sceneProperties.minT = Q1 + (sceneProperties.minTBar - 2500) / 2500 * (Q2 - Q1);
				}
				else if(sceneProperties.minTBar < 7500){
					sceneProperties.minT = Q2 + (sceneProperties.minTBar - 5000) / 2500 * (Q3 - Q2);
				}
				else if(sceneProperties.minTBar < 9500){
					sceneProperties.minT = Q3 + (sceneProperties.minTBar - 7500) / 2000 * (20000 - Q3);
					
				}
				else{
					sceneProperties.minT = 20000 + (sceneProperties.minTBar - 9500) / 500 * (max - 20000);
				}
				MinTcontroller.name('Min Temperature: ' + sceneProperties.minT.toFixed(0).toString());


			reRenderScene(0);
			}
			);
			MinRcontroller.onChange(()=>{
				renderMode = 0;
				PlanetfilterFolder.close();
				min = RadQs[0];
				max = RadQs[1];
				Q1 = RadQs[2];
				Q2 = RadQs[3];
				Q3 = RadQs[4];
				console.log("Barvalue",sceneProperties.minRBar);
				
				if(sceneProperties.minRBar < 2500){
					sceneProperties.minR = sceneProperties.minRBar / 2500 * Q1;
				}
				else if(sceneProperties.minRBar < 5000){
					sceneProperties.minR = Q1 + (sceneProperties.minRBar - 2500) / 2500 * (Q2 - Q1);
				}
				else if(sceneProperties.minRBar < 7500){
					sceneProperties.minR = Q2 + (sceneProperties.minRBar - 5000) / 2500 * (Q3 - Q2);
				}
				else if(sceneProperties.minRBar < 9500){
					sceneProperties.minR = Q3 + (sceneProperties.minRBar - 7500) / 2000 * (50 - Q3);
					
				}
				else{
					sceneProperties.minR = 50 + (sceneProperties.minRBar - 9500) / 500 * (max - 50);
				}
				
				MinRcontroller.name('Min Radius: ' + sceneProperties.minR.toFixed(3).toString());
				reRenderScene(0);
			}
			);
			
			var PlanetfilterFolder = gui.addFolder('Planet Features');
			pl_MaxMcontroller = PlanetfilterFolder.add(sceneProperties, 'pl_maxMBar', 0, 10000).name('Max Earth Mass:89700').onChange(()=>reRenderScene(0));
			pl_MinMcontroller = PlanetfilterFolder.add(sceneProperties, 'pl_minMBar', 0, 10000).name('Min Earth Mass: 0').onChange(()=>reRenderScene(0));
			pl_MaxRcontroller = PlanetfilterFolder.add(sceneProperties, 'pl_maxRBar', 0, 10000).name('Max Earth Radius:77.342').onChange(()=>reRenderScene(0));
			pl_MinRcontroller = PlanetfilterFolder.add(sceneProperties, 'pl_minRBar', 0, 10000).name('Min Earth Radius:0').onChange(()=>reRenderScene(0));
			pl_MaxDenscontroller = PlanetfilterFolder.add(sceneProperties, 'pl_maxDensBar', 0, 10000).name('Max Density: 18').onChange(()=>reRenderScene(0));
			pl_MinDenscontroller = PlanetfilterFolder.add(sceneProperties, 'pl_minDensBar', 0, 10000).name('Min Density: 0').onChange(()=>reRenderScene(0));
			//创建名为discmethod的下拉列表
			PlanetfilterFolder.add(sceneProperties, 'discmethod',["Transit", "Radial Velocity", "Microlensing","others","all"]).name("Discovery Method").onChange(()=>reRenderScene(0));
			PlanetfilterFolder.add(sceneProperties, 'disclocale',["Space", "Ground", "Multiple Locales","all"]).name("Discovery Locale").onChange(()=>reRenderScene(0));
			PlanetfilterFolder.add(sceneProperties, 'disctelescope',["Kepler Telescope", "TESS Telescope", "Multiple Telescopes","others","all"]).name("Discovery Telescope").onChange(()=>reRenderScene(0));
			PlanetfilterFolder.add(sceneProperties, 'discfacility',["Kepler", "K2", "TESS","others","all"]).name("Discovery Facility").onChange(()=>reRenderScene(0));
			

			pl_MaxMcontroller.onChange(()=>{
				renderMode = 1;
				filterFolder.close();
				min = pl_massQs[0];
				max = pl_massQs[1];
				Q1 = pl_massQs[2];
				Q2 = pl_massQs[3];
				Q3 = pl_massQs[4];
				if(sceneProperties.pl_maxMBar < 2500){
					sceneProperties.pl_maxM = sceneProperties.pl_maxMBar / 2500 * Q1;
				}
				else if(sceneProperties.pl_maxMBar < 5000){
					sceneProperties.pl_maxM = Q1 + (sceneProperties.pl_maxMBar - 2500) / 2500 * (Q2 - Q1);
				}
				else if(sceneProperties.pl_maxMBar < 7500){
					sceneProperties.pl_maxM = Q2 + (sceneProperties.pl_maxMBar - 5000) / 2500 * (Q3 - Q2);
				}
				else if(sceneProperties.pl_maxMBar < 9500){
					sceneProperties.pl_maxM = Q3 + (sceneProperties.pl_maxMBar - 7500) / 2000 * (2000 - Q3);
					
				}
				else{
					sceneProperties.pl_maxM = 20000 + (sceneProperties.pl_maxMBar - 9500) / 500 * (max - 2000);
				}
				//console.log("pl_maxM",sceneProperties.pl_maxM);
				pl_MaxMcontroller.name('Max Earth Mass: '+sceneProperties.pl_maxM.toFixed(2).toString());
				reRenderScene(0);
			}
			);
			pl_MinRcontroller.onChange(()=>{
				renderMode = 1;
				filterFolder.close();
				min = pl_radQs[0];
				max = pl_radQs[1];
				Q1 = pl_radQs[2];
				Q2 = pl_radQs[3];
				Q3 = pl_radQs[4];
				if(sceneProperties.pl_minRBar < 2500){
					sceneProperties.pl_minR = sceneProperties.pl_minRBar / 2500 * Q1;
				}
				else if(sceneProperties.pl_minRBar < 5000){
					sceneProperties.pl_minR = Q1 + (sceneProperties.pl_minRBar - 2500) / 2500 * (Q2 - Q1);
				}
				else if(sceneProperties.pl_minRBar < 7500){
					sceneProperties.pl_minR = Q2 + (sceneProperties.pl_minRBar - 5000) / 2500 * (Q3 - Q2);
				}
				else if(sceneProperties.pl_minRBar < 9500){
					sceneProperties.pl_minR = Q3 + (sceneProperties.pl_minRBar - 7500) / 2000 * (25 - Q3);
					
				}
				else{
					sceneProperties.pl_minR = 25 + (sceneProperties.pl_minRBar - 9500) / 500 * (max - 25);
				}
				//console.log("pl_minR",sceneProperties.pl_minR);
				pl_MinRcontroller.name('Min Earth Radius: '+sceneProperties.pl_minR.toFixed(3).toString());
			reRenderScene(0);
			}
			);
			pl_MinMcontroller.onChange(()=>{
				renderMode = 1;
				filterFolder.close();
				min = pl_massQs[0];
				max = pl_massQs[1];
				Q1 = pl_massQs[2];
				Q2 = pl_massQs[3];
				Q3 = pl_massQs[4];
				if(sceneProperties.pl_minMBar < 2500){
					sceneProperties.pl_minM = sceneProperties.pl_minMBar / 2500 * Q1;
				}
				else if(sceneProperties.pl_minMBar < 5000){
					sceneProperties.pl_minM = Q1 + (sceneProperties.pl_minMBar - 2500) / 2500 * (Q2 - Q1);
				}
				else if(sceneProperties.pl_minMBar < 7500){
					sceneProperties.pl_minM = Q2 + (sceneProperties.pl_minMBar - 5000) / 2500 * (Q3 - Q2);
				}
				else if(sceneProperties.pl_minMBar < 9500){
					sceneProperties.pl_minM = Q3 + (sceneProperties.pl_minMBar - 7500) / 2000 * (2000 - Q3);
					
				}
				else{
					sceneProperties.pl_minM = 2000 + (sceneProperties.pl_minMBar - 9500) / 500 * (max - 2000);
				}
				//console.log("pl_minM",sceneProperties.pl_minM);
				pl_MinMcontroller.name('Min Earth Mass: '+sceneProperties.pl_minM.toFixed(2).toString());
				reRenderScene(0);
			}
			);


			pl_MaxRcontroller.onChange(()=>{
				renderMode = 1;
				min = pl_radQs[0];
				max = pl_radQs[1];
				Q1 = pl_radQs[2];
				Q2 = pl_radQs[3];
				Q3 = pl_radQs[4];
				if(sceneProperties.pl_minRBar < 2500){
					sceneProperties.pl_maxR = sceneProperties.pl_maxRBar / 2500 * Q1;
				}
				else if(sceneProperties.pl_maxRBar < 5000){
					sceneProperties.pl_maxR = Q1 + (sceneProperties.pl_maxRBar - 2500) / 2500 * (Q2 - Q1);
				}
				else if(sceneProperties.pl_maxRBar < 7500){
					sceneProperties.pl_maxR = Q2 + (sceneProperties.pl_maxRBar - 5000) / 2500 * (Q3 - Q2);
				}
				else if(sceneProperties.pl_maxRBar < 9500){
					sceneProperties.pl_maxR = Q3 + (sceneProperties.pl_maxRBar - 7500) / 2000 * (25 - Q3);
					
				}
				else{
					sceneProperties.pl_maxR = 25 + (sceneProperties.pl_maxRBar - 9500) / 500 * (max - 25);
				}
				//console.log("pl_maxR",sceneProperties.pl_maxR);
				pl_MaxRcontroller.name('Max Earth Radius: '+sceneProperties.pl_maxR.toFixed(3).toString());
				filterFolder.close();
				reRenderScene(0);
			}
			);
			pl_MinDenscontroller.onChange(()=>{
				
				renderMode = 1;
				min = DensityQs[0];
				max = DensityQs[1];
				Q1 = DensityQs[2];
				Q2 = DensityQs[3];
				Q3 = DensityQs[4];
				if(sceneProperties.pl_minDensBar < 2500){
					sceneProperties.pl_minDens = sceneProperties.pl_minDensBar / 2500 * Q1;
				}
				else if(sceneProperties.pl_minDensBar < 5000){
					sceneProperties.pl_minDens = Q1 + (sceneProperties.pl_minDensBar - 2500) / 2500 * (Q2 - Q1);
				}
				else if(sceneProperties.pl_minDensBar < 7500){
					sceneProperties.pl_minDens = Q2 + (sceneProperties.pl_minDensBar - 5000) / 2500 * (Q3 - Q2);
				}
				else if(sceneProperties.pl_minDensBar < 9500){
					sceneProperties.pl_minDens = Q3 + (sceneProperties.pl_minDensBar - 7500) / 2000 * (9 - Q3);
					
				}
				else{
					sceneProperties.pl_minDens = 9 + (sceneProperties.pl_minDensBar - 9500) / 500 * (max - 9);
				}
				//console.log("pl_minDens",sceneProperties.pl_minDens);
				pl_MinDenscontroller.name('Min Density: '+sceneProperties.pl_minDens.toFixed(2).toString());
				filterFolder.close();
				reRenderScene(0);
			}
			);
			pl_MaxDenscontroller.onChange(()=>{

				min = DensityQs[0];
				max = DensityQs[1];
				Q1 = DensityQs[2];
				Q2 = DensityQs[3];
				Q3 = DensityQs[4];
				if(sceneProperties.pl_maxDensBar < 2500){
					sceneProperties.pl_maxDens = sceneProperties.pl_maxDensBar / 2500 * Q1;
				}
				else if(sceneProperties.pl_maxDensBar < 5000){
					sceneProperties.pl_maxDens = Q1 + (sceneProperties.pl_maxDensBar - 2500) / 2500 * (Q2 - Q1);
				}
				else if(sceneProperties.pl_maxDensBar < 7500){
					sceneProperties.pl_maxDens = Q2 + (sceneProperties.pl_maxDensBar - 5000) / 2500 * (Q3 - Q2);
				}
				else if(sceneProperties.pl_maxDensBar < 9500){
					sceneProperties.pl_maxDens = Q3 + (sceneProperties.pl_maxDensBar - 7500) / 2000 * (9 - Q3);
					
				}
				else{
					sceneProperties.pl_maxDens = 9 + (sceneProperties.pl_maxDensBar - 9500) / 500 * (max - 9);
				}
				//console.log("pl_minDens",sceneProperties.pl_minDens);
				pl_MaxDenscontroller.name('Max Density: '+sceneProperties.pl_maxDens.toFixed(2).toString());
				renderMode = 1;
				reRenderScene(0);
				filterFolder.close();
				
			}
			);
			
			filterFolder.open();
			//PlanetfilterFolder.open();
			reloadFolder.open();
			gui.open();	
			
		</script>
	</body>
</html>
